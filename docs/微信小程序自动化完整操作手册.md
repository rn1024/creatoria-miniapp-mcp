# 微信小程序自动化完整操作手册

> 官方文档：<https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/quick-start.html>
>
> 本文档涵盖所有可用的自动化接口和操作功能

---

## 📑 目录

- [1. 快速入门](#1-快速入门)
- [2. Automator API](#2-automator-api)
- [3. MiniProgram API](#3-miniprogram-api)
- [4. Page API](#4-page-api)
- [5. Element API](#5-element-api)
- [6. 常用示例](#6-常用示例)
- [7. 真机自动化](#7-真机自动化)
- [8. 录制回放](#8-录制回放)
- [9. FAQ](#9-faq)

---

## 1. 快速入门

### 1.1 运行环境

- **Node.js**: 版本大于 8.0
- **基础库**: 版本 `2.7.3` 及以上
- **开发者工具**: 版本 `1.02.1907232` 及以上

### 1.2 安装

```bash
npm i miniprogram-automator --save-dev
```

### 1.3 使用

**第一步**：开启工具安全设置中的 **CLI/HTTP 调用功能**

> ⚠️ 必须开启以上选项，否则 SDK 将无法正常启动工具自动化功能

**第二步**：编写控制脚本

```javascript
const automator = require('miniprogram-automator')

automator.launch({
  cliPath: 'path/to/cli', // 工具 cli 位置，默认安装位置可忽略
  projectPath: 'path/to/project', // 项目文件地址
}).then(async miniProgram => {
  const page = await miniProgram.reLaunch('/page/component/index')
  await page.waitFor(500)
  const element = await page.$('.kind-list-item-hd')
  console.log(await element.attribute('class'))
  await element.tap()
  await miniProgram.close()
})
```

**第三步**：执行脚本

```bash
node path/to/script
```

---

## 2. Automator API

Automator 模块提供了启动及连接开发者工具的方法。

### 2.1 automator.connect

连接开发者工具。

```typescript
automator.connect(options: Object): Promise<MiniProgram>
```

**参数说明**

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| wsEndpoint | string | 是 | - | 开发者工具 WebSocket 地址 |

**命令行参数**

- `--auto <project_root>`: 打开指定项目并开启自动化功能
- `--auto-port <port>`: 指定自动化监听端口

```bash
cli --auto /Users/username/demo --auto-port 9420
```

**示例代码**

```javascript
automator.connect({
  wsEndpoint: 'ws://localhost:9420'
}).then(async miniProgram => {
  const page = await miniProgram.navigateTo('/page/component/index')
  await page.setData({})
})
```

### 2.2 automator.launch

启动并连接开发者工具。

> ⚠️ 确保工具安全设置中已开启 CLI/HTTP 调用功能

```typescript
automator.launch(options: Object): Promise<MiniProgram>
```

**参数说明**

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| cliPath | string | 否 | - | 开发者工具命令行工具绝对路径 |
| projectPath | string | 是 | - | 项目绝对路径 |
| timeout | number | 否 | 30000 | 启动最长等待时间（毫秒） |
| port | number | 否 | - | WebSocket 端口号 |
| account | string | 否 | - | 用户 openid |
| projectConfig | Object | 否 | - | 覆盖 project.config.json 中的配置 |
| ticket | string | 否 | - | 开发者工具登录票据 |

**cliPath 默认位置**

- **Mac**: `/Applications/wechatwebdevtools.app/Contents/MacOS/cli`
- **Windows**: `C:/Program Files (x86)/Tencent/微信web开发者工具/cli.bat`

**示例代码**

```javascript
automator.launch({
  cliPath: 'path/to/cli',
  projectPath: 'path/to/project',
  projectConfig: {
    setting: {
      autoAudits: true,
    },
  },
}).then(async miniProgram => {
  const page = await miniProgram.navigateTo('/page/component/index')
  await page.setData({})
})
```

---

## 3. MiniProgram API

MiniProgram 模块提供了控制小程序的方法。

### 3.1 页面导航方法

#### 3.1.1 miniProgram.pageStack

获取小程序页面堆栈。

```typescript
miniProgram.pageStack(): Promise<Page[]>
```

#### 3.1.2 miniProgram.navigateTo

保留当前页面，跳转到应用内的某个页面，同 `wx.navigateTo`。

```typescript
miniProgram.navigateTo(url: string): Promise<Page>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| url | string | 是 | 需要跳转的应用内非 tabBar 的页面的路径 |

#### 3.1.3 miniProgram.redirectTo

关闭当前页面，跳转到应用内的某个页面，同 `wx.redirectTo`。

```typescript
miniProgram.redirectTo(url: string): Promise<Page>
```

#### 3.1.4 miniProgram.navigateBack

关闭当前页面，返回上一页面或多级页面，同 `wx.navigateBack`。

```typescript
miniProgram.navigateBack(): Promise<Page>
```

#### 3.1.5 miniProgram.reLaunch

关闭所有页面，打开到应用内的某个页面，同 `wx.reLaunch`。

```typescript
miniProgram.reLaunch(url: string): Promise<Page>
```

#### 3.1.6 miniProgram.switchTab

跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面，同 `wx.switchTab`。

```typescript
miniProgram.switchTab(url: string): Promise<Page>
```

#### 3.1.7 miniProgram.currentPage

获取当前页面。

```typescript
miniProgram.currentPage(): Promise<Page>
```

### 3.2 系统信息方法

#### 3.2.1 miniProgram.systemInfo

获取系统信息，同 `wx.getSystemInfo`。

```typescript
miniProgram.systemInfo(): Promise<Object>
```

**示例代码**

```javascript
const systemInfo = await miniProgram.systemInfo()
if (systemInfo.platform === 'devtools') {
  // Do something
}
```

### 3.3 方法调用与Mock

#### 3.3.1 miniProgram.callWxMethod

调用 wx 对象上的指定方法。

```typescript
miniProgram.callWxMethod(method: string, ...args: any[]): Promise<any>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| method | string | 是 | 需要调用的方法名 |
| ...args | array\<any\> | 否 | 方法参数 |

> 💡 调用异步方法时无需传入 success 及 fail 回调函数

**示例代码**

```javascript
await miniProgram.callWxMethod('setStorage', {
  key: 'test',
  data: 'test'
})
const { data } = await miniProgram.callWxMethod('getStorageSync', 'test')
console.log(data) // -> 'test'
```

#### 3.3.2 miniProgram.callPluginWxMethod

> 📌 基础库 2.19.3 开始支持

调用插件 wx 对象上的指定方法，用法同 `miniProgram.callWxMethod`。

```typescript
miniProgram.callPluginWxMethod(pluginId: string, method: string, ...args: any[]): Promise<any>
```

#### 3.3.3 miniProgram.mockWxMethod

> 📌 传入函数功能 automator 0.9.0，基础库 2.9.5 开始支持

覆盖 wx 对象上指定方法的调用结果。

```typescript
miniProgram.mockWxMethod(method: string, result: any): Promise<void>
miniProgram.mockWxMethod(method: string, fn: Function | string, ...args: any[]): Promise<void>
```

**参数说明 - 方式一**

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| method | string | 是 | 需要覆盖的方法名 |
| result | any | 是 | 指定调用结果 |

**参数说明 - 方式二**

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| method | string | 是 | 需要覆盖的方法名 |
| fn | Function \| string | 是 | 处理返回函数 |
| ...args | array\<any\> | 否 | 传入参数 |

> ⚠️ fn 同 `miniProgram.evaluate` 的 appFunction 参数一样，无法使用闭包来引用外部变量。此外，你还可以在方法内使用 `this.origin` 来调用原始方法。

**示例代码**

```javascript
// 方式一：直接指定结果
await miniProgram.mockWxMethod('showModal', {
  confirm: true,
  cancel: false
})

// 方式二：使用函数处理
await miniProgram.mockWxMethod(
  'getStorageSync',
  function(key, defVal) {
    if (key === 'name') return 'redhoodsu'
    if (key === 'sex') return 'male'
    return defVal
  },
  'unknown',
)

// 更改 getSystemInfo 中的 platform 字段
await miniProgram.mockWxMethod(
  'getSystemInfo',
  function(obj, platform) {
    return new Promise(resolve => {
      this.origin({
        success(res) {
          res.platform = platform
          resolve(res)
        },
      })
    })
  },
  'test',
)
```

#### 3.3.4 miniProgram.mockPluginWxMethod

> 📌 基础库 2.19.3 开始支持

覆盖插件 wx 对象上指定方法的调用结果，用法同 `miniProgram.mockWxMethod`。

```typescript
miniProgram.mockPluginWxMethod(pluginId: string, method: string, result: any): Promise<void>
miniProgram.mockPluginWxMethod(pluginId: string, method: string, fn: Function | string, ...args: any[]): Promise<void>
```

#### 3.3.5 miniProgram.restoreWxMethod

重置 wx 指定方法，消除 mockWxMethod 调用的影响。

```typescript
miniProgram.restoreWxMethod(method: string): Promise<void>
```

**示例代码**

```javascript
console.log(await miniProgram.callWxMethod('getStorageSync', 'test')) // -> ''
await miniProgram.mockWxMethod('getStorageSync', 'mockValue')
console.log(await miniProgram.callWxMethod('getStorageSync', 'test')) // -> 'mockValue'
await miniProgram.restoreWxMethod('getStorageSync')
console.log(await miniProgram.callWxMethod('getStorageSync', 'test')) // -> ''
```

#### 3.3.6 miniProgram.restorePluginWxMethod

> 📌 基础库 2.19.3 开始支持

重置插件 wx 指定方法，消除 mockPluginWxMethod 调用的影响，用法同 `miniProgram.restoreWxMethod`。

```typescript
miniProgram.restorePluginWxMethod(pluginId: string, method: string): Promise<void>
```

### 3.4 代码执行方法

#### 3.4.1 miniProgram.evaluate

往 AppService 注入代码片段并返回执行结果。

```typescript
miniProgram.evaluate(appFunction: Function | string, ...args: any[]): Promise<any>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| appFunction | Function \| string | 是 | 代码片段 |
| ...args | array\<any\> | 否 | 执行时传入参数 |

> ⚠️ appFunction 最终会被序列化传递到开发者工具，因此你无法在函数中利用闭包来引用外部变量。

**示例代码**

```javascript
// 方式一：使用 Promise
let systemInfo = await miniProgram.evaluate(() => {
  return new Promise(resolve => {
    wx.getSystemInfo({
      success(result) {
        resolve(result)
      }
    })
  })
})

// 方式二：同步方法
systemInfo = await miniProgram.evaluate(() => {
  return wx.getSystemInfoSync()
})

// 方式三：带参数
await miniProgram.evaluate(key => {
  wx.setStorageSync(key, 'test')
}, 'test')

// 获取全局数据
const hasLogin = await miniProgram.evaluate(() => getApp().globalData.hasLogin)
```

### 3.5 页面操作方法

#### 3.5.1 miniProgram.pageScrollTo

将页面滚动到目标位置，同 `wx.pageScrollTo`。

```typescript
miniProgram.pageScrollTo(scrollTop: number): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| scrollTop | number | 是 | 滚动到页面的目标位置，单位 px |

**示例代码**

```javascript
await miniProgram.pageScrollTo(50)
```

#### 3.5.2 miniProgram.screenshot

> 📌 automator 0.9.0，基础库 2.9.5，开发者工具 1.02.2001082 开始支持

对当前页面截图，目前只有开发者工具模拟器支持，客户端无法使用。

```typescript
miniProgram.screenshot(options?: Object): Promise<string | void>
```

**参数说明**

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| options | Object | 否 | - | 截图选项 |

如果不传 options，该方法返回图片数据的 base64 编码。

**options 字段**

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| path | string | 是 | 图片保存路径 |

**示例代码**

```javascript
await miniProgram.screenshot({
  path: 'screenshot.png'
})
```

### 3.6 高级功能

#### 3.6.1 miniProgram.exposeFunction

在 AppService 全局暴露方法，供小程序侧调用测试脚本中的方法。

```typescript
miniProgram.exposeFunction(name: string, bindingFunction: Function): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| name | string | 是 | 全局方法名 |
| bindingFunction | Function | 是 | 脚本方法 |

> 💡 你可以利用该方法来监听事件，不支持在小程序侧获取调用结果。

**示例代码**

```javascript
await miniProgram.exposeFunction('onAppShow', options => {
  // Do something...
})

await miniProgram.evaluate(function() {
  wx.onAppShow(function(options) {
    onAppShow(options)
  })
})
```

#### 3.6.2 miniProgram.testAccounts

> 📌 automator 0.9.0，开发者工具 1.02.2002272 开始支持

获取多账号调试中已添加的用户列表。

```typescript
miniProgram.testAccounts(): Promise<Account[]>
```

**Account 字段**

| 字段 | 类型 | 说明 |
|------|------|------|
| nickName | string | 用户昵称 |
| openid | string | 账号 openid |

**示例代码**

```javascript
const testAccounts = await miniProgram.testAccounts()
for (let i = 0, len = testAccounts.length; i < len; i++) {
  const miniProgram = await automator.launch({
    projectPath: 'path/to/project',
    account: testAccounts[i].openid
  })
  // 控制多个用户登录的不同小程序
}
```

#### 3.6.3 miniProgram.stopAudits

> 📌 automator 0.10.0，开发者工具 1.04.2006242 开始支持

停止体验评分并获取报告。

```typescript
miniProgram.stopAudits(options?: Object): Promise<Object>
```

**参数说明**

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| options | Object | 否 | - | 选项 |

**options 字段**

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| path | string | 否 | - | 报告保存路径 |

> ⚠️ 需要开启自动运行体验评分选项

**示例代码**

```javascript
automator.launch({
  projectConfig: {
    setting: {
      autoAudits: true,
    },
  },
}).then(async miniProgram => {
  const data = await miniProgram.stopAudits({
    path: 'report.html'
  })
  console.log(data) // 体验评分报告数据
})
```

### 3.7 票据管理

#### 3.7.1 miniProgram.getTicket

获取开发者工具当前的登录票据。

> ⚠️ 确保工具安全设置中已开启允许获取工具登录票据功能

```typescript
miniProgram.getTicket(): Promise<Object>
```

**返回值说明**

| 字段 | 类型 | 说明 |
|------|------|------|
| ticket | string | 登录票据 |
| expiredTime | number | 票据过期时间 |

**示例代码**

```javascript
const result = await miniProgram.getTicket()
console.log(result.ticket)
```

#### 3.7.2 miniProgram.setTicket

设置开发者工具登录票据，可在工具运行测试期间更新失效的登录票据。

```typescript
miniProgram.setTicket(ticket: string): Promise<void>
```

**示例代码**

```javascript
// ticket 从已登录的开发者工具获取
automator.launch({
  ticket,
}).then(async miniProgram => {
  // 如果初始票据已失效，获取新票据后通过 setTicket 更新
  await miniProgram.setTicket(ticket)
})
```

#### 3.7.3 miniProgram.refreshTicket

刷新开发者工具登录票据，可以使票据过期时间重置为两小时。

```typescript
miniProgram.refreshTicket(): Promise<void>
```

> ⚠️ 刷新票据后原有的票据即使过期时间未到也会过期

**示例代码**

```javascript
await miniProgram.refreshTicket()
```

### 3.8 真机调试

#### 3.8.1 miniProgram.remote

开启工具真机调试功能。

```typescript
miniProgram.remote(auto?: boolean): Promise<void>
```

| 字段 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| auto | boolean | 否 | false | 是否自动真机调试 |

调用后脚本会启动工具真机调试功能，并且在控制台上打印二维码，然后你需要使用真机扫码连接使自动化脚本继续跑下去。

> 💡 auto 为 true 时，真机上会自动调起小程序，无需扫码，仅支持微信 7.0.6（安卓）、6.6.7（iOS）及以上版本

**示例代码**

```javascript
await miniProgram.remote()
// 扫码连接成功后在真机上执行自动化脚本
```

### 3.9 连接管理

#### 3.9.1 miniProgram.disconnect

断开与小程序运行时的连接。

```typescript
miniProgram.disconnect(): void
```

**示例代码**

```javascript
miniProgram.disconnect()
```

#### 3.9.2 miniProgram.close

断开与小程序运行时的连接并关闭项目窗口。

```typescript
miniProgram.close(): Promise<void>
```

**示例代码**

```javascript
await miniProgram.close()
```

### 3.10 事件监听

#### 3.10.1 console

日志打印时触发。

**msg 参数字段**

| 字段 | 类型 | 说明 |
|------|------|------|
| type | string | 日志类型，log、info 等 |
| args | array\<any\> | 日志内容 |

**示例代码**

```javascript
miniProgram.on('console', msg => {
  console.log(msg.type, msg.args)
})
```

#### 3.10.2 exception

页面 JS 出错时触发。

**error 参数字段**

| 字段 | 类型 | 说明 |
|------|------|------|
| message | string | 错误信息 |
| stack | string | 错误堆栈 |

**示例代码**

```javascript
miniProgram.on('exception', err => {
  console.log(err.message, err.stack)
})
```

---

## 4. Page API

Page 模块提供了控制小程序页面的方法。

### 4.1 属性

#### 4.1.1 page.path

页面路径。

```typescript
page.path: string
```

#### 4.1.2 page.query

页面参数。

```typescript
page.query: Object
```

### 4.2 元素选择方法

#### 4.2.1 page.$

获取页面元素。

```typescript
page.$(selector: string): Promise<Element>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| selector | string | 是 | 选择器 |

> 💡 同 WXSS，仅支持部分 CSS 选择器

**示例代码**

```javascript
const page = await miniProgram.currentPage()
const element = await page.$('.index-desc')
console.log(element.tagName) // -> 'view'
```

#### 4.2.2 page.$$

获取页面元素数组。

```typescript
page.$$(selector: string): Promise<Element[]>
```

> ⚠️ 该方法跟 $ 一样均无法选择自定义组件内的元素，请使用 `element.$`

**示例代码**

```javascript
const elements = await page.$$('.kind-list-text')
console.log(elements.length)
```

### 4.3 等待方法

#### 4.3.1 page.waitFor

等待直到指定条件成立。

```typescript
page.waitFor(condition: string | number | Function): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| condition | string \| number \| Function | 是 | 等待条件 |

**条件类型说明**

- **string 类型**: 当成选择器，当该选择器选中元素个数不为零时，结束等待
- **number 类型**: 当成超时时长，当经过指定时间后，结束等待
- **Function 类型**: 当成断言函数，当该函数返回真值时，结束等待

**示例代码**

```javascript
await page.waitFor(5000) // 等待 5 秒
await page.waitFor('picker') // 等待页面中出现 picker 元素
await page.waitFor(async () => {
  return (await page.$$('picker')).length > 5
}) // 等待页面中 picker 元素数量大于 5
```

### 4.4 数据操作方法

#### 4.4.1 page.data

> 📌 传递数据路径 automator 0.6.0，基础库 2.9.0 开始支持

获取页面渲染数据。

```typescript
page.data(path?: string): Promise<Object>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| path | string | 否 | 数据路径 |

**示例代码**

```javascript
console.log(await page.data('list'))
```

#### 4.4.2 page.setData

设置页面渲染数据。

```typescript
page.setData(data: Object): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| data | Object | 是 | 要改变的数据 |

**示例代码**

```javascript
await page.setData({
  text: 'changed data'
})
```

### 4.5 页面信息方法

#### 4.5.1 page.size

获取页面大小。

```typescript
page.size(): Promise<Object>
```

**返回值说明**

| 字段 | 类型 | 说明 |
|------|------|------|
| width | number | 页面可滚动宽度 |
| height | number | 页面可滚动高度 |

**示例代码**

```javascript
const { width, height } = await page.size()
console.log(width, height)
```

#### 4.5.2 page.scrollTop

> 📌 automator 0.7.0 开始支持

获取页面滚动位置。

```typescript
page.scrollTop(): Promise<number>
```

**示例代码**

```javascript
await miniProgram.pageScrollTo(20)
console.log(await page.scrollTop())
```

### 4.6 方法调用

#### 4.6.1 page.callMethod

调用页面指定方法。

```typescript
page.callMethod(method: string, ...args: any[]): Promise<any>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| method | string | 是 | 需要调用的方法名 |
| ...args | array\<any\> | 否 | 方法参数 |

**示例代码**

```javascript
await page.callMethod('onShareAppMessage')
```

---

## 5. Element API

Element 模块提供了控制小程序页面元素的方法。

### 5.1 属性

#### 5.1.1 element.tagName

标签名，小写。

```typescript
element.tagName: string
```

### 5.2 元素查询方法

#### 5.2.1 element.$

在元素范围内获取元素。

```typescript
element.$(selector: string): Promise<Element>
```

**示例代码**

```javascript
let element = await page.$('.index-hd')
element = await element.$('.index-desc')
console.log(await element.text())
```

#### 5.2.2 element.$$

在元素范围内获取元素数组。

```typescript
element.$$(selector: string): Promise<Element[]>
```

**示例代码**

```javascript
const element = await page.$('.index-bd')
const elements = await element.$$('.kind-list-text')
console.log(await elements[0].text())
```

### 5.3 元素信息方法

#### 5.3.1 element.size

获取元素大小。

```typescript
element.size(): Promise<Object>
```

**返回值说明**

| 字段 | 类型 | 说明 |
|------|------|------|
| width | number | 元素宽度 |
| height | number | 元素高度 |

**示例代码**

```javascript
const { width, height } = await element.size()
console.log(width, height)
```

#### 5.3.2 element.offset

获取元素绝对位置。

```typescript
element.offset(): Promise<Object>
```

**返回值说明**

| 字段 | 类型 | 说明 |
|------|------|------|
| left | number | 左上角 x 坐标，单位：px |
| top | number | 左上角 y 坐标，单位：px |

> 💡 坐标信息以页面左上角为原点

**示例代码**

```javascript
const { left, top } = await element.offset()
console.log(left, top)
```

#### 5.3.3 element.text

获取元素文本。

```typescript
element.text(): Promise<string>
```

**示例代码**

```javascript
const element = await page.$('.index-desc')
console.log(await element.text())
```

### 5.4 属性与样式方法

#### 5.4.1 element.attribute

获取元素特性。

```typescript
element.attribute(name: string): Promise<string>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| name | string | 是 | 特性名 |

**示例代码**

```javascript
const element = await page.$('.index-logo')
console.log(await element.attribute('src')) // -> 'resources/kind/logo.png'
```

#### 5.4.2 element.property

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

获取元素属性。

```typescript
element.property(name: string): Promise<any>
```

**element.property 与 element.attribute 主要区别**

- `element.attribute` 获取的是标签上的值，因此它的返回类型一定是字符串，`element.property` 则不一定
- `element.attribute` 可以获取到 class 和 id 之类的值，`element.property` 不行
- `element.property` 可以获取到文档里对应组件列举的大部分属性值，比如表单 input 等组件的 value 值

**示例代码**

```javascript
const element = await page.$('input')
console.log(await element.property('value'))
```

#### 5.4.3 element.wxml

获取元素 WXML。

```typescript
element.wxml(): Promise<string>
```

#### 5.4.4 element.outerWxml

同 wxml，只是会获取到元素本身。

```typescript
element.outerWxml(): Promise<string>
```

**示例代码**

```javascript
const element = await page.$('.index-desc')
console.log(await element.wxml())
console.log(await element.outerWxml())
```

#### 5.4.5 element.value

获取元素值。

```typescript
element.value(): Promise<string>
```

**示例代码**

```javascript
const element = await page.$('.weui-input')
console.log(await element.value())
```

#### 5.4.6 element.style

获取元素样式值。

```typescript
element.style(name: string): Promise<string>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| name | string | 是 | 样式名 |

**示例代码**

```javascript
const element = await page.$('.index-desc')
console.log(await element.style('color')) // -> 'rgb(136, 136, 136)'
```

### 5.5 交互操作方法

#### 5.5.1 element.tap

点击元素。

```typescript
element.tap(): Promise<void>
```

**示例代码**

```javascript
const element = await page.$('.kind-list-item-hd')
await element.tap()
```

#### 5.5.2 element.longpress

长按元素。

```typescript
element.longpress(): Promise<void>
```

#### 5.5.3 element.touchstart

> 📌 automator 0.8.0，基础库 2.9.1 开始支持

手指开始触摸元素。

```typescript
element.touchstart(options: Object): Promise<void>
```

**options 字段**

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| touches | array\<Touch\> | 是 | 触摸事件，当前停留在屏幕中的触摸点信息的数组 |
| changedTouches | array\<Touch\> | 是 | 触摸事件，当前变化的触摸点信息的数组 |

#### 5.5.4 element.touchmove

> 📌 automator 0.8.0，基础库 2.9.1 开始支持

手指触摸元素后移动。

```typescript
element.touchmove(options: Object): Promise<void>
```

> 💡 options 字段同 touchstart

#### 5.5.5 element.touchend

> 📌 automator 0.8.0，基础库 2.9.1 开始支持

手指结束触摸元素。

```typescript
element.touchend(options: Object): Promise<void>
```

> 💡 options 字段同 touchstart

**综合示例代码**

```javascript
const element = await page.$('.touch')

await element.touchstart({
  touches: [{
    identifier: 1,
    pageX: 500,
    pageY: 500
  }],
  changedTouches: [{
    identifier: 1,
    pageX: 500,
    pageY: 500
  }]
})

await element.touchend({
  touches: [],
  changedTouches: [{
    identifier: 1,
    pageX: 500,
    pageY: 500
  }]
})
```

#### 5.5.6 element.trigger

触发元素事件。

```typescript
element.trigger(type: string, detail?: Object): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| type | string | 是 | 触发事件类型 |
| detail | Object | 否 | 触发事件时传递的 detail 值 |

**示例代码**

```javascript
const element = await page.$('picker')
await element.trigger('change', { value: 1 })
```

> ⚠️ 该方法无法改变组件状态，仅触发响应方法，也无法触发用户操作事件，即 tap，longpress 等事件，请使用对应的其它方法调用

#### 5.5.7 element.input

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

输入文本，仅 input、textarea 组件可以使用。

```typescript
element.input(value: string): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| value | string | 是 | 需要输入的文本 |

**示例代码**

```javascript
const element = await page.$('input')
await element.input('test')
```

### 5.6 组件方法

#### 5.6.1 element.callMethod

> 📌 automator 0.6.0，基础库 2.9.0 开始支持

调用组件实例指定方法，仅自定义组件可以使用。

```typescript
element.callMethod(method: string, ...args: any[]): Promise<any>
```

**示例代码**

```javascript
const element = await page.$('set-tab-bar')
await element.callMethod('navigateBack')
```

#### 5.6.2 element.data

> 📌 automator 0.6.0，基础库 2.9.0 开始支持

获取组件实例渲染数据，仅自定义组件可以使用。

```typescript
element.data(path?: string): Promise<Object>
```

**示例代码**

```javascript
const element = await page.$('set-tab-bar')
console.log(await element.data('hasSetTabBarBadge'))
```

#### 5.6.3 element.setData

> 📌 automator 0.6.0，基础库 2.9.0 开始支持

设置组件实例渲染数据，仅自定义组件可以使用。

```typescript
element.setData(data: Object): Promise<void>
```

**示例代码**

```javascript
const element = await page.$('set-tab-bar')
await element.setData({
  hasSetTabBarBadge: true
})
```

#### 5.6.4 element.callContextMethod

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

调用上下文 Context 对象方法，仅 video 组件可以使用。

```typescript
element.callContextMethod(method: string, ...args: any[]): Promise<any>
```

> ⚠️ video 组件必须设置了 id 才能使用

**示例代码**

```javascript
const element = await page.$('video')
await element.callContextMethod('play')
```

### 5.7 滚动视图方法

#### 5.7.1 element.scrollWidth

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

获取滚动宽度，仅 scroll-view 组件可以使用。

```typescript
element.scrollWidth(): Promise<number>
```

#### 5.7.2 element.scrollHeight

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

获取滚动高度，仅 scroll-view 组件可以使用。

```typescript
element.scrollHeight(): Promise<number>
```

#### 5.7.3 element.scrollTo

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

滚动到指定位置，仅 scroll-view 组件可以使用。

```typescript
element.scrollTo(x: number, y: number): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| x | number | 是 | 横向滚动位置 |
| y | number | 是 | 纵向滚动位置 |

**示例代码**

```javascript
const element = await page.$('scroll-view')
const y = (await element.scrollHeight()) - 50
await element.scrollTo(0, y)
```

### 5.8 其他组件专用方法

#### 5.8.1 element.swipeTo

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

滑动到指定滑块，仅 swiper 组件可以使用。

```typescript
element.swipeTo(index: number): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| index | number | 是 | 目标滑块的 index |

**示例代码**

```javascript
const element = await page.$('swiper')
await element.swipeTo(2)
```

#### 5.8.2 element.moveTo

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

移动视图容器，仅 movable-view 组件可以使用。

```typescript
element.moveTo(x: number, y: number): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| x | number | 是 | x 轴方向的偏移 |
| y | number | 是 | y 轴方向的偏移 |

**示例代码**

```javascript
const element = await page.$('movable-view')
await element.moveTo(40, 40)
```

#### 5.8.3 element.slideTo

> 📌 automator 0.9.0，基础库 2.9.5 开始支持

滑动到指定数值，仅 slider 组件可以使用。

```typescript
element.slideTo(value: number): Promise<void>
```

| 字段 | 类型 | 必填 | 说明 |
|------|------|------|------|
| value | number | 是 | 要设置的值 |

**示例代码**

```javascript
const element = await page.$('slider')
await element.slideTo(10)
```

---

## 6. 常用示例

这里提供一些常用的测试方法示例，以帮助你更好地去使用自动化 SDK 完成测试任务。

### 6.1 错误处理

SDK 的方法调用有可能会抛出错误，比如 `miniProgram.navigateTo('path/to/page')` 在页面不存在时会出错。

在可能出错的代码上，你可以使用 `try catch` 进行处理：

```javascript
automator.launch().then(async miniProgram => {
  let page
  try {
    page = await miniProgram.navigateTo('/page/component/index')
  } catch (e) {
    // 处理出错情况
    console.log(e.message)
  }
})
```

### 6.2 模板测试

小程序的模板是由 WXML 标记语言编写的。在执行时，小程序会将模板和页面数据相结合渲染出最终的页面来。测试框架 Jest 提供了一项很棒的**快照**功能。利用这个特性和 SDK 提供的设置页面数据接口，你可以很轻松地测试模板文件在不同数据下渲染出来的结果是否正确。

下面是小程序示例测试接口页模板的代码示例：

```javascript
const automator = require('miniprogram-automator')

describe('api', () => {
  let miniProgram
  let page

  beforeAll(async () => {
    miniProgram = await automator.launch({
      projectPath: 'path/to/miniprogram-demo'
    })
    page = await miniProgram.reLaunch('/page/API/index')
    await page.waitFor(500)
  })

  afterAll(async () => {
    await miniProgram.close()
  })

  it('wxml', async () => {
    const element = await page.$('page')
    expect(await element.wxml()).toMatchSnapshot()
    await page.setData({
      list: []
    })
    expect(await element.wxml()).toMatchSnapshot()
  })
})
```

### 6.3 测试环境

在测试时，有时候你可能需要执行一些特殊逻辑，比如使用测试账号，或者使用不同的请求地址。这种情况我们建议在小程序代码中植入这部分代码，然后在全局对象 globalData 上设置开关，通过 SDK 提供的执行代码片段功能在测试时开启。

下面是小程序示例测试登录接口页模板的代码示例：

```javascript
const automator = require('miniprogram-automator')

describe('api', () => {
  let miniProgram
  let page

  beforeAll(async () => {
    miniProgram = await automator.launch({
      projectPath: 'path/to/miniprogram-demo'
    })
    // 直接更改全局变量
    await miniProgram.evaluate(() => {
      getApp().globalData.hasLogin = true
    })
    page = await miniProgram.reLaunch('/page/API/pages/login/login')
    await page.waitFor(500)
  })

  afterAll(async () => {
    await miniProgram.close()
  })

  it('wxml', async () => {
    const element = await page.$('page')
    expect(await element.wxml()).toMatchSnapshot()
  })
})
```

### 6.4 伪造请求结果

在测试环境中，有时为了模拟各种情况，需要对 wx 方法调用的结果进行伪造，比如伪造地理位置、伪造请求结果等，这种情况下就可以使用 `miniProgram.mockWxMethod`。

下面是伪造特定请求结果的代码示例：

```javascript
const automator = require('miniprogram-automator')

describe('api', () => {
  let miniProgram

  beforeAll(async () => {
    miniProgram = await automator.launch({
      projectPath: 'path/to/miniprogram-demo'
    })
  })

  afterAll(async () => {
    await miniProgram.close()
  })

  it('request', async () => {
    const mockData = [
      {
        rule: 'testRequest',
        result: {
          data: 'test',
          cookies: [],
          header: {},
          statusCode: 200,
        },
      },
    ]

    await miniProgram.mockWxMethod(
      'request',
      function(obj, data) {
        for (let i = 0, len = data.length; i < len; i++) {
          const item = data[i]
          const rule = new RegExp(item.rule)
          if (rule.test(obj.url)) {
            return item.result
          }

          // 没命中规则的真实访问后台
          return new Promise(resolve => {
            obj.success = res => resolve(res)
            obj.fail = res => resolve(res)
            this.origin(obj)
          })
        }
      },
      mockData,
    )

    const result = await miniProgram.callWxMethod('request', {
      url: 'https://14592619.qcloud.la/testRequest',
    })
    console.log(result.data) // -> 'test'
    await miniProgram.restoreWxMethod('request')
  })
})
```

---

## 7. 真机自动化

小程序自动化除了能够控制开发者工具中的小程序模拟器，也支持通过远程调试控制真机，以达到在真机上进行自动化测试的目的。

### 7.1 运行环境

- 确保目标机器上的基础库版本为 `2.7.3` 及以上

### 7.2 使用方式

在编写完测试用例并且在工具模拟器上测试成功之后，假如想要在真机上跑自动化，可以通过以下两种方法实现。

#### 7.2.1 通过 SDK 启动

你可以在测试脚本开头使用 `miniProgram.remote` 接口启动工具的真机调试功能，调用成功后脚本会在控制台打印二维码。使用目标机器扫码成功连接后，脚本会继续在真机上执行下去。

**脚本示例**

```javascript
const automator = require('miniprogram-automator')

automator.launch({
  cliPath: 'path/to/cli',
  projectPath: 'path/to/project',
}).then(async miniProgram => {
  await miniProgram.remote() // 扫码登录连接真机，在真机上执行后续测试脚本
  const page = await miniProgram.reLaunch('/page/component/index')
  await page.waitFor(500)
  const element = await page.$('.kind-list-item-hd')
  console.log(await element.attribute('class'))
  await element.tap()
  await miniProgram.close()
})
```

#### 7.2.2 手工启动

如果工具是打开常驻并且使用 `automator.connect` 接口进行连接，那么可以先手工启用工具的真机调试功能后再运行测试脚本，这样就可以在真机上测试小程序了。

---

## 8. 录制回放

开发者可以将测试操作提前录制好，然后通过执行录制脚本来实现测试过程的回放。

### 8.1 运行环境要求

- 下载并安装 `1.05.2110202` 或以上版本的开发者工具
- 基础库版本为 `2.19.6` 及以上

### 8.2 使用流程

#### 8.2.1 工具 -> 自动化测试

通过工具菜单打开自动化测试窗口。

#### 8.2.2 新建用例并开始录制

新建会弹出一个新建弹窗，允许：

- 修改用例名
- 选择是否开启 mock
- 修改录制时的最大等待时间（默认值为 10s）
- 配置规则忽略随机生成的 classname
- 配置清除缓存选项

开始录制后，正常点击小程序元素可进行录制，录制结束后可以再微调等待时间等。

#### 8.2.3 CGI Mock

支持 mock `wx.request`/`wx.cloud.callFunction` 等接口。

> 💡 云开发相关的接口支持的最低工具版本是 `1.06.2206242`

#### 8.2.4 断言/检查

录制时可以记录 data 快照/wxml 快照，用于回放时匹配校验，或者选择检查元素，断言元素存在/innertext 是否相等。

**支持的断言类型：**

1. **data 快照**: 记录当前 `page.data` 数据，回放时进行匹配
2. **wxml 快照**: 记录 wxml 字符串
3. **检查元素**: 检查元素是否存在或文本内容
4. **截屏** (工具最低可用版本 `1.06.2206090`): 以 base64 格式存储截屏结果

#### 8.2.5 重新录制

重新录制会覆盖之前录制的用例步骤。

#### 8.2.6 回放

点击回放可进行回放操作，失败会标注失败原因。另外，支持扫码后在真机回放用例。

#### 8.2.7 回放全部

选择回放全部，会生成一个简易测试报告，并保存到本地。

也可选择使用工具命令行回放：

```bash
# 打开自动化测试窗口
cli auto-replay --project /Users/username/demo

# 打开自动化测试窗口并回放全部测试用例
cli auto-replay --project /Users/username/demo --replay-all
```

#### 8.2.8 回放配置

工具版本 `1.06.2211012` 以上允许配置回放时截图：

- 如果配置失败时截图，则图片内容以 base64 存放在回放结果文件中
- 如果配置每个步骤都截图，则图片保存在和回放结果文件的同名文件夹中

#### 8.2.9 小程序云测回放

本地回放时，是基于开发者工具本地代码版本。如果开发者希望在其他小程序版本测试（如回归测试中在体验版对多个用例进行回放），可以尝试使用**小程序云测**。

小程序云测支持将录制好的用例，在开发中版本、体验版、线上版进行回放，支持定时任务/API 任务，并生成详细的测试报告。

### 8.3 其他功能

#### 8.3.1 企业微信小程序支持

工具版本 `1.06.2209152` 以上支持企业微信小程序进行录制回放自动化测试。切换到企业微信小程序模式，然后企业微信基础库选择 2.20.3，即可和普通小程序一样使用录制回放功能。

#### 8.3.2 测试账号切换

点击头像，可切换测试账号。

#### 8.3.3 配置文件说明

测试保存目录默认在 `minitest/`，可在 `project.config.json` 修改：

```json
"testRoot": "minitest/"
```

---

## 9. FAQ

### 9.1 怎么操作系统原生组件，如用户授权、位置选择等？

用户授权框等系统组件不提供方法获取和操作，请在执行自动化测试前确保已手工对所需权限进行授权。

位置选择等调用 wx 对象接口触发的原生界面组件，可以直接使用 `miniProgram.mockWxMethod` 指定返回结果。

### 9.2 Node.js 脚本执行完为什么不会退出？

请确保在测试执行完毕后调用 `miniProgram.close` 或者 `miniProgram.disconnect` 断开与工具的连接。

### 9.3 怎么在一台机器上登录多个账号测试？

可以使用工具的多账号调试功能，配合自动化的 `miniProgram.testAccounts` 来达到目的。

### 9.4 怎么在多个机器上的工具登录相同账号运行测试？

利用 `miniProgram.getTicket` 接口可以获取到当前工具的登录票据，然后就可以使用该票据在其它机器上登录工具。票据具体怎么从机器上同步到另一台机器上，需要开发者自行维护。

---

## 📚 附录

### A. CLI 默认路径

**Mac**

```bash
/Applications/wechatwebdevtools.app/Contents/MacOS/cli
```

**Windows**

```bash
C:/Program Files (x86)/Tencent/微信web开发者工具/cli.bat
```

### B. 版本要求总结

| 功能 | 最低版本要求 |
|------|-------------|
| 基本自动化 | 基础库 2.7.3 + 工具 1.02.1907232 |
| 传入函数 Mock | automator 0.9.0 + 基础库 2.9.5 |
| 插件 wx 方法调用 | 基础库 2.19.3 |
| 截图功能 | automator 0.9.0 + 基础库 2.9.5 + 工具 1.02.2001082 |
| 录制回放 | 基础库 2.19.6 + 工具 1.05.2110202 |
| 云开发 Mock | 工具 1.06.2206242 |
| 企业微信小程序 | 工具 1.06.2209152 |

### C. 相关链接

- 官方文档：<https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/>
- Jest 官网：<https://jestjs.io/>
- 小程序示例：<https://github.com/wechat-miniprogram/miniprogram-demo>

---

## 🎯 完整测试示例

```javascript
const automator = require('miniprogram-automator')

describe('Mini Program Automation Test', () => {
  let miniProgram
  let page

  beforeAll(async () => {
    miniProgram = await automator.launch({
      projectPath: 'path/to/project'
    })
    page = await miniProgram.reLaunch('/page/index/index')
    await page.waitFor(500)
  }, 30000)

  afterAll(async () => {
    await miniProgram.close()
  })

  it('should navigate to detail page', async () => {
    const button = await page.$('.nav-button')
    await button.tap()
    await page.waitFor(500)
    expect((await miniProgram.currentPage()).path).toBe('page/detail/detail')
  })

  it('should input text correctly', async () => {
    const input = await page.$('input')
    await input.input('test text')
    expect(await input.value()).toBe('test text')
  })

  it('should handle mock request', async () => {
    await miniProgram.mockWxMethod('request', {
      data: { success: true },
      statusCode: 200
    })
    const result = await miniProgram.callWxMethod('request', {
      url: 'https://api.example.com/test'
    })
    expect(result.data.success).toBe(true)
    await miniProgram.restoreWxMethod('request')
  })
})
```

---

**文档版本**: v1.0
**最后更新**: 2025-10-02
**整理来源**: 微信小程序官方文档
